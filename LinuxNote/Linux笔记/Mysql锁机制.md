# Mysql锁机制

## 一、表锁（偏向MyISAM，偏读）
​ 表级锁是mysql锁中粒度最大的一种锁，表示当前的操作对整张表加锁，资源开销比行锁少，不会出现死锁的情况，但是发生锁冲突的概率很大。被大部分的mysql引擎支持，MyISAM和InnoDB都支持表级锁，但是InnoDB默认的是行级锁。

##### 共享锁用法：

    LOCK TABLE table_name [ AS alias_name ] READ

##### 排它锁用法：

    LOCK TABLE table_name [AS alias_name][ LOW_PRIORITY ] WRITE

##### 解锁用法：

    unlock tables;
    
##### 查看哪些表加锁
    show open tables;
    
##### 分析表锁定
    show status like 'table%'
    //Table_locks_immediate：产生表级锁定的次数
    //Table_locks_waited：出现表级锁定争用而发生等待的次数


## 结论

###### 简而言之，就是读锁会阻塞写，但是不阻塞读。而写锁会吧读和写都堵塞。


## 二、行锁（偏向InnoDB，偏写）

行级锁是Mysql中锁定粒度最细的一种锁，表示只针对当前操作的行进行加锁。**行级锁能大大减少数据库操作的冲突。其加锁粒度最小，但加锁的开销也最大。有可能会出现死锁的情况。**行级锁按照使用方式分为共享锁和排他锁。

##### 共享锁用法（S锁 读锁）：

​ 若事务T对数据对象A加上S锁，则事务T可以读A但不能修改A，其他事务只能再对A加S锁，而不能加X锁，直到T释放A上的S锁。这保证了其他事务可以读A，但在T释放A上的S锁之前不能对A做任何修改。

    select ... lock in share mode;

**共享锁就是允许多个线程同时获取一个锁，一个锁可以同时被多个线程拥有。**

##### 排它锁用法（X 锁 写锁）：

​ 若事务T对数据对象A加上X锁，事务T可以读A也可以修改A，其他事务不能再对A加任何锁，直到T释放A上的锁。这保证了其他事务在T释放A上的锁之前不能再读取和修改A。

    select ... for update
    
​ 排它锁，也称作独占锁，一个锁在某一时刻只能被一个线程占有，其它线程必须等待锁被释放之后才可能获取到锁。

## 三、页锁
​ 页级锁是MySQL中锁定粒度介于行级锁和表级锁中间的一种锁。表级锁速度快，但冲突多，行级冲突少，但速度慢。所以取了折衷的页级，一次锁定相邻的一组记录。BDB支持页级锁