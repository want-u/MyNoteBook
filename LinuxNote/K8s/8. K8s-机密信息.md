# K8s-机密信息

用k8s管理机密信息

## 1. Secret介绍

k8s secrets用于存储和管理一些敏感数据，比如密码，token，密钥等敏感信息。它把 Pod 想要访问的加密数据存放到 Etcd 中。然后用户就可以通过在 Pod 的容器里***\*挂载 Volume 的方式\****或者***环境变量\***的方式访问到这些 Secret 里保存的信息了。

 

Secret有三种类型

1. **Opaque**：base64 编码格式的 Secret，用来存储密码、密钥等；但数据也可以通过base64 –decode解码得到原始数据，所有加密性很弱。
2. **Service Account**：用来访问Kubernetes API，由Kubernetes自动创建，并且会自动挂载到Pod的 /run/secrets/kubernetes.io/serviceaccount 目录中。
3. **kubernetes.io/dockerconfigjson** ： 用来存储私有docker registry的认证信息。

## 2. 创建

***方式一： kubectl create secret 命令***

```
# 直接接收键值对

[root@k8s-master ~]# kubectl create secret generic mysecret1 --from-literal=username=admin --from-literal=password=123456
secret/mysecret1 created
[root@k8s-master ~]# kubectl get secrets 
NAME                  TYPE                                  DATA   AGE
default-token-5msbv   kubernetes.io/service-account-token   3      17d
mysecret1             Opaque                                2      9s
```

```
# 以文件的方式

[root@k8s-master ~]# mkdir mysecret
[root@k8s-master ~]# cd mysecret/
[root@k8s-master mysecret]# echo -n admin > username
[root@k8s-master mysecret]# echo -n admin

[root@k8s-master mysecret]# kubectl create secret generic mysecret2 --from-file=username --from-file=password 
secret/mysecret2 created
[root@k8s-master mysecret]# kubectl get secrets 
NAME                  TYPE                                  DATA   AGE
default-token-5msbv   kubernetes.io/service-account-token   3      17d
mysecret1             Opaque                                2      4m9s
mysecret2             Opaque                                2      10s
```

```
# 以env的方式，可以保存多个键值对

[root@k8s-master mysecret]# cat env.test 
username=admin
password=123456

[root@k8s-master mysecret]# kubectl create secret generic mysecret3 --from-env-file=env.test 
secret/mysecret3 created

```

***方式二： 通过yaml文件创建\***

```
[root@k8s-master mysecret]# kubectl create secret generic mysecret4 --from-env-file=env.test --dry-run=client -o yaml > mysecret4.yml

[root@k8s-master mysecret]# cat mysecret4.yml 
apiVersion: v1
data:
  password: MTIzNDU2
  username: YWRtaW4=
kind: Secret
metadata:
  name: mysecret4

# 密码经过base64加密
[root@k8s-master mysecret]# echo -n 123456 | base64
MTIzNDU2
  
# 应用yaml文件，创建secret  
[root@k8s-master mysecret]# kubectl apply -f mysecret4.yml 
[root@k8s-master mysecret]# kubectl get secrets 
NAME                  TYPE                                  DATA   AGE
default-token-5msbv   kubernetes.io/service-account-token   3      17d
mysecret1             Opaque                                2      10m
mysecret2             Opaque                                2      6m35s
mysecret3             Opaque                                2      4m34s
mysecret4             Opaque                                2      6s

# 查看详情
[root@k8s-master mysecret]# kubectl describe secrets mysecret1
Name:         mysecret1
Namespace:    default
Labels:       <none>
Annotations:  <none>

Type:  Opaque

Data
====
password:  6 bytes
username:  5 bytes

# 查看密码值
[root@k8s-master mysecret]# kubectl edit secrets mysecret1 
# 使用base64反编译值
[root@k8s-master mysecret]# echo -n MTIzNDU2 | base64 --decode
```

## 3.secret使用

***方式一：通过Volume挂载的方式***

```
[root@k8s-master mysecret]# kubectl run mypod --image=busybox --dry-run=client -o yaml > mypod.yaml
  
[root@k8s-master mysecret]# cat mypod.yaml 
apiVersion: v1
kind: Pod
metadata:
  labels:
    run: mypod
  name: mypod
spec:
  containers:
  - image: busybox
    name: mypod
    args: ["/bin/sh","-c","sleep 999999"]

    volumeMounts:
    - name: foo
      mountPath: "/etc/foo"
      readOnly: true
  volumes:
  - name: foo
    secret:
      secretName: mysecret1
      
[root@k8s-master mysecret]# kubectl apply -f mypod.yaml 


# 进入容器查看
[root@k8s-master mysecret]# kubectl exec -it mypod -- sh
/etc/foo # cd /etc/foo/
/etc/foo # ls
password  username
```

```
# 定义secret挂载
[root@k8s-master mysecret]# cat mypod.yaml 
apiVersion: v1
kind: Pod
metadata:
  labels:
    run: mypod
  name: mypod
spec:
  containers:
  - image: busybox
    name: mypod
    args: ["/bin/sh","-c","sleep 999999"]

    volumeMounts:
    - name: foo
      mountPath: "/etc/foo"
      readOnly: true
  volumes:
  - name: foo
    secret:
      secretName: mysecret4
      items:
      - key: username
        path: my-test/myusername
      - key: password
        path: my-test/mypassword

# 查看
[root@k8s-master mysecret]# kubectl exec -it mypod -- sh
/ # cd /etc/foo/
/etc/foo # cd my-test/
/etc/foo/..2021_03_25_06_40_28.525961402/my-test # ls
mypassword  myusername
/etc/foo/..2021_03_25_06_47_19.541182192/my-test # cat mypassword 
123456/etc/foo/..2021_03_25_06_47_19.541182192/my-test #
```

## 更新secret

```
# 修改密码

[root@k8s-master mysecret]# echo -n 654321 | base64
NjU0MzIx

[root@k8s-master mysecret]# cat mysecret4.yml 
apiVersion: v1
data:
  password: NjU0MzIx
  username: YWRtaW4=
kind: Secret
metadata:
  name: mysecret4

# 修改secret
[root@k8s-master mysecret]# kubectl apply -f mysecret4.yml
# 再次进入容器查看
```

```
# env变量

[root@k8s-master mysecret]# cat mypod.yaml 
apiVersion: v1
kind: Pod
metadata:
  labels:
    run: mypod
  name: mypod
spec:
  containers:
  - image: busybox
    name: mypod
    args: ["/bin/sh","-c","sleep 999999"]

    env:
      - name: SECRET_USERNAME
        valueFrom:
          secretKeyRef:
            name: mysecret4
            key: username

      - name: SECRET_PASSWORD
        valueFrom:
          secretKeyRef:
            name: mysecret4
            key: password

# 应用yaml文件
[root@k8s-master mysecret]# kubectl apply -f mypod.yaml 
[root@k8s-master mysecret]# kubectl get pod 
NAME    READY   STATUS    RESTARTS   AGE
mypod   1/1     Running   0          24s
# 查看变量
[root@k8s-master mysecret]# kubectl exec -it mypod -- sh
/ # echo $SECRET_USERNAME
admin

```

## ConfigMap

ConfigMap顾名思义，是用于保存配置数据的键值对，可以用来保存单个属性，也可以保存配置文件。Secret可以为Pod提供密码、Token、私钥等敏感数据；对于一些非敏感数据，比如应用的配置信息，则可以使用ConfigMap。

## ConfigMap的创建

可以使用 `kubectl create configmap` 从文件、目录或者 key-value 字符串创建等创建 ConfigMap。也可以通过 `kubectl create -f`从描述文件创建。

### 从key-value字符串创建

```csharp
$ kubectl create configmap special-config --from-literal=special.how=very
configmap "special-config" created
$ kubectl get configmap special-config -o go-template='{{.data}}'
map[special.how:very]
```

上面的命令创建了一个名为special-config，拥有一条key为special.how，value为very的键值对数据。

### 从env文件创建

```swift
$ echo -e "a=b\nc=d" | tee config.env
a=b
c=d
$ kubectl create configmap special-config --from-env-file=config.env
configmap "special-config" created
$ kubectl get configmap special-config -o go-template='{{.data}}'
map[a:b c:d]
```

上面的命令从一个env文件读取键值对，然后存入一个名为special-config的ConfigMap中。

### 从目录创建

```ruby
$ mkdir config
$ echo a>config/a
$ echo b>config/b
$ kubectl create configmap special-config --from-file=config/
configmap "special-config" created
$ kubectl get configmap special-config -o go-template='{{.data}}'
map[a:a
 b:b
]
```

上面的命令读取config目录下的所有文件，以文件名为key，文件内容为value，存入名为special-config的ConfigMap中。

### 根据yaml描述文件创建

```css
apiVersion: v1
kind: ConfigMap
metadata:
  name: special-config
data:
  special.how: very
  special.type: charm
```

```ruby
$ kubectl create  -f  config.yaml
configmap "special-config" created
```