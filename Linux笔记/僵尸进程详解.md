# 僵尸进程详解

- https://www.cnblogs.com/yychuyu/p/15553400.html
- https://www.cnblogs.com/centos-python/articles/14348425.html

1. 僵尸进程defunct
    - 子进程先于父进程退出，同时父进程太忙了，无瑕回收子进程的资源
    - kill 父进程 或重启容器
2. 孤儿进程
    - 父进程先于子进程结束，则子进程成为孤儿进程
    - 例nginx父进程1 重启nginx进程

[toc]

## 僵尸进程详解

### Linux中的进程是什么？

讲到进程，我们要先了解一下另一个概念：`程序`。

程序说白了就是躺在电脑硬盘上的一个文件而已（如同硬盘女神一样），在被 CPU 执行之前，它啥也做不了。

当程序被执行之后，它运行的实例就称为`进程` 。一个程序可以对应多个进程。

进程是系统的工作单元。系统由多个进程组成，其中有的是操作系统进程（执行系统代码），其他的是用户进程（执行用户代码）。所有这些进程都会并发执行，例如通过在单 CPU 上采用多路复用来实现。

你可以使用 `ps` 命令查看 Linux 系统中的所有进程 。

```
$ ps -ax
        PID TTY         STAT   TIME COMMAND
        1 ?     Ss      0:01 /usr/lib/systemd/systemd rhgb --switched-root --sys
        2 ?     S       0:00 [kthreadd]
        3 ?     I<      0:00 [rcu_gp]
        4 ?     I<      0:00 [rcu_par_gp]
```

当一个进程调用 `fork` 函数生成另一个进程，原进程就称为父进程，新生成的进程则称为子进程。

Linux 系统中这样父子进程非常多，我们可以使用 `pstree` 命令查看系统上的进程「谱系」。

```
$ pstree -psn
systemd(1)─┬─systemd-journal(952)
        ├─systemd-udevd(963)
        ├─systemd-oomd(1137)
        ├─systemd-resolve(1138)
        ├─systemd-userdbd(1139)─┬─systemd-userwor(12707)
        │                     ├─systemd-userwor(12714)
        │                     └─systemd-userwor(12715)
        ├─auditd(1140)───{auditd}(1141)
        ├─dbus-broker-lau(1164)───dbus-broker(1165)
        ├─avahi-daemon(1166)───avahi-daemon(1196)
        ├─bluetoothd(1167)
```

每个进程在系统中都被分配了一个编号。在这所有的进程中，有个非常特殊的进程，它的 ID 号是 1 。它是系统在引导过程中执行的第一个进程，PID 1 之后的每个后续进程都是它的后代。

### 什么是僵尸进程？

前面提到过，在 Linux 环境中，我们是通过 `fork` 函数来创建子进程的。创建完毕之后，父子进程独立运行，父进程无法预知子进程什么时候结束。

通常情况下，子进程退出后，父进程会使用 `wait` 或 `waitpid` 函数进行回收子进程的资源，并获得子进程的终止状态。

但是，如果父进程先于子进程结束，则子进程成为孤儿进程。孤儿进程将被 init 进程（进程号为1）领养，并由 init 进程对孤儿进程完成状态收集工作。

而如果子进程先于父进程退出，同时父进程太忙了，无瑕回收子进程的资源，子进程残留资源（PCB）存放于内核中，变成僵尸（Zombie）进程，如下图所示：

![img](https://img2020.cnblogs.com/other/1218435/202111/1218435-20211114211743830-1369830674.jpg)

### 僵尸进程是怎么产生的？

前面已经介绍了僵尸进程产生的原理，下面我们通过代码来模拟僵尸进程的产生。

```
#include  
#include  
#include  
#include  

int main(void)  
{  
    pid_t pid;  
    pid = fork();  
    if (pid == 0) {  
            printf("I am child, my parent= %d, going to sleep 3s\n", getppid());  
            sleep(3);  
            printf("-------------child die--------------\n");  
    } else if (pid > 0) {  
            printf("I am parent, pid = %d, myson = %d, going to sleep 5s\n", getpid(), pid);  
            sleep(5);  
            system("ps -o pid,ppid,state,tty,command");  
    } else {  
        perror("fork");  
        return 1;  
    }  

    return 0;  
}  
```

在这个程序里，父进程创建子进程之后，就休眠 5 秒钟。而子进程只休眠 3 秒钟就退出，在它退出之后，父进程还未苏醒，因此没人给子进程「收尸」，所以它就变成了僵尸进程。

![img](https://img2020.cnblogs.com/other/1218435/202111/1218435-20211114211744054-727798369.jpg)

### 如何杀死僵尸进程

对于普通进程，我们可以通过使用 `kill` 命令来杀死它们。`kill` 命令它还有几个兄弟，比如 `pkill` 和 `killall` ，虽然它们名称里都带 `kill` 这样杀气腾腾的字眼，但它们实际上是被设计为向一个或多个进程发送信号。

在未指定的情况下，这几个命令默认发送的是 `SIGTERM` 信号。

普通进程可以被 `kill` ，但僵尸进程是不行的。为什么？因为僵尸进程本身就已经「死」过一次了！如果还可以再「死」，那「僵尸」这个名号就没多大意义了。

僵尸进程其实已经就是退出的进程，因此无法再利用kill命令杀死僵尸进程。僵尸进程的罪魁祸首是父进程没有回收它的资源，那我们可以想办法它其它进程去回收僵尸进程的资源，这个进程就是 init 进程。

因此，我们可以直接杀死父进程，init 进程就会很善良地把那些僵尸进程领养过来，并合理的回收它们的资源，那些僵尸进程就得到了妥善的处理了。

例如，如果 PID 5878 是一个僵尸进程，它的父进程是 PID 4809，那么要杀死僵尸进程 （5878），您可以结束父进程 （4809）：

```
$ sudo kill -9 4809  #4809 is the parent, not the zombie
```

杀死父进程时要非常小心，如果一个进程的父进程就是 PID 1 ，并且你还杀死了它，那么系统将直接重启！

这将是一个更可怕的故事！


---

## 解决容器中的僵尸进程

今天遇到一个问题，是我们的jenkins-node 突然出现好多僵尸进程

ps -ef |egrep defunct 

sh [defunct]

基本都是这种进程

通过前述的 ps 命令，我们发现这些 zombies 的父进程基本都是 jenkins-agent 进程

通过网上搜索发现是我们启动的父进程是1 的进程（我这里是jenkins-agent 进程）不具备`init` 系统的功能，也就不会将操作系统的信号转发到子进程上，也不会回收孤儿进程，所以会产生大量的僵尸进程

这和我启动jenkins-node的方式有关我构建的Dockerfile的启动方式是直接CMD 

![img](https://img2020.cnblogs.com/blog/1344156/202101/1344156-20210130111027695-1078403242.png)

 

 这样启动的容器必然是jenkins-agent 的进程为1 ，不具备init 系统具备的功能，所以会产生大量的僵尸进程，又无法回收

这里介绍一下init 系统应该具备的功能

### `init` 系统特点

- 它是系统的第一个进程，负责产生其他所有用户进程。
- init 以守护进程方式存在，是所有其他进程的祖先。
- 它主要负责：
  - 启动守护进程
  - 回收孤儿进程
  - 将操作系统信号转发给子进程 

所以解决方案是启动一个具备init进程的进程来启动相应的容器，按照网上的解决最终选择tini

![img](https://img2020.cnblogs.com/blog/1344156/202101/1344156-20210130111406905-281186742.png)

 

 

![img](https://img2020.cnblogs.com/blog/1344156/202101/1344156-20210130111309094-751268331.png)

init 系统有很多种，这里推荐使用 tini，它是专用于容器的轻量级 init 系统

https://github.com/krallin/tini

如果你想直接通过 docker 命令来运行容器，可以直接通过参数 `--init` 来使用 tini，不需要在镜像中安装 tini。如果是 `Kubernetes` 就不行了，还得老老实实安装 tini

### 最终的解决方案

ENTRYPOINT ["/sbin/tini", "--", "/usr/local/bin/jenkins.sh"]

![img](https://img2020.cnblogs.com/blog/1344156/202101/1344156-20210130112508584-541826845.png)

 

 

 ![img](https://img2020.cnblogs.com/blog/1344156/202101/1344156-20210130112552999-658788743.png)