# 分组函数


[toc]    
##### 0.简单介绍
功能：用作统计，又称聚合函数或统计函数或组函数

分类：sum，avg，max，min，count

特点：
1. sum，avg用于处理数值型，max，min，count可以处理任何类型
2. 以上分组函数都忽略null值
3. 可以和distinct搭配，实现去重
4. count函数的介绍，一般使用count(*)统计行数
5. 和分组函数一同查询的字段要求时gruop by后的字段

##### 1.简单的使用
    select sum(salary) from employees;
    select avg(salary) from employees;
    select min(salary) from employees;
    select max(salary) from employees;
    select count(salary) from employees;
    
    select sum(salary) 和,avg(salary) 平均 from employees;
    select sum(salary) 和,round(avg(salary),2) 平均 from employees;
    
##### 2.参数支持哪些类型
    sum,avg:数值型
    select sum(last_name),avg(last_name) from employees;
    
    max,min:数值，字符，日期
    select max(last_name),min(last_name) from employees;
    select max(hiredate),min(hiredate) from employees;
    
    count:任何类型
    select count(commission_pct) from employees;
    select count(last_name) from employees;
    
##### 3.是否忽略null
    select sum(commission_pct),avg(commission_pct) from employees;
    
##### 4.和distinct搭配
    select sum(distinct salary),sum(salary) from employees;
    select count(distinct salary),count(salary) from employees;
    
##### 5.count函数的详细介绍
    select count(salary) from employees; #统计字段
    select count(*) from employees; #统计行数
    select count(1) from employees; #加一列的1，统计行数
    
    效率：
        MYISAM存储引擎下，count(*)最快
        INNODB存储引擎下，count(*)和count(1)的效率差不多，比count(字段)高一些
        
##### 6.和分组函数一同查询的字段有限制
    
##### 案例练习
    select max(salary),min(salary),round(avg(salary),2),sum(salary) from employees;
    select datediff(max(hiredate),min(hiredate)) as DIFFENCE from employees;
    select count(*) from employees where department_id=90;
    
# 分组函数进阶
    语法：  select 分组函数，列(要求出现在group by后面)
            from 表
            [where 筛选条件]
            group by 分组的列表分组后的筛选
            [having ]
            [order by 子句]
    要求：查询列表必须特殊，要求是分组函数和group by后面出现的字段
    
    特点：
        1.分组查询中的筛选条件分为分组前筛选和分组后筛选
            （where 原始表，group by，having 分组后的结果集）
            分组函数做条件肯定放在having子句
        2.group by 子句支持单个字段分组，多个字段分组（逗号隔开无顺序），表达式分组
        3.也可以排序（排序放最后）
    
    
    引入：查询每个部门的平均工资
    select department_id,avg(salary) from employees group by department_id;
    
##### 1.简单的分组查询案例
    1.每个工种的最高工资
    select max(salary),job_id from employees group by job_id;
    
    2.查询每个位置上的部门个数
    select count(*),location_id from departments group by location_id;
    
##### 2.添加分组前的筛选条件
    1.查询邮箱中包含a字符的，每个部门的平均工资
    select avg(salary),department_id from employees where email like '%a%' group by department_id;
    
    2.查询有奖金的每个领导手下员工的最高工资
    select max(salary),manager_id from employees where commission_pct is not null group by manager_id;
    
##### 3.添加分组后的筛选条件
    1.查询哪个部门的员工个数大于二
        ①查询每个部门的员工个数
        select count(*),department_id from employees group by department_id;
        
        ②根据上一把筛选员工数大于2的部门
        select count(*),department_id from employees group by department_id having count(*)>2;
         
    2.查询每个工种有奖金的员工的最高工资大于12000的工种编号和最高工资
    select max(salary),job_id from employees where commission_pct is not null group by job_id having max(salary)>12000;
    
    3.查询领导编号>102的每个领导首席的最低工资>5000的领导编号和最低工资
    select min(salary),manager_id from employees 
    where manager_id>102 
    group by manager_id 
    having min(salary)>5000;
    
##### 4.按表达式或函数分组
    1.按员工姓名的长度分组，查询每组的员工个数，筛选员工数大于5的
    select count(*),length(last_name) 
    from employees 
    group by length(last_name) having count(*)>5;
    
    select count(*) as c,length(last_name) as name from employees group by name having c>5;
    
##### 5.按多个字段分组
    1.查询每个部门每个工种的员工的平均工资(部门和工种相同为一组)
    select avg(salary),department_id,job_id 
    from employees 
    group by department_id,job_id;
    
##### 6.添加排序
    1.查询每个部门每个工种的员工的平均工资(部门和工种相同为一组),按平均工资高低显示
    select avg(salary),department_id,job_id 
    from employees 
    where department_id is not null
    group by department_id,job_id
    having avg(salary)>10000
    order by avg(salary) desc;
    

##### 案例查询
    select max(salary),min(salary),avg(salary),sum(salary),job_id 
    from employees
    group by job_id
    order by job_id;
    
    select max(salary)-min(salary) DIFFERENCE 
    from employees;
    
    select min(salary),manager_id 
    from employees
    where manager_id is not null
    group by manager_id
    having min(salary)>=6000;
    
    select department_id,count(*),avg(salary) as a
    from employees
    group by department_id
    order by a desc;
    
    select count(*),job_id 
    from employees
    group by job_id;
    
    
# 连接查询
    select 字段1，字段2
    from 表1，表2...
    where 连接条件

    含义：又称多表查询，当查询的字段来自于多个表，就会用到连接查询
    笛卡尔乘积现象：表1有m行，表2有n行，结果为m*n行
    发生原因：没有有效的连接条件
    如何避免：添加有效的连接条件
    
    分类：
        按年代标准：
            sql92标准：mysql仅支持内连接
            sql99标准（推荐）：支持内连接，外连接（左外连接，右外连接），交叉连接
        按功能分类：
            内连接：
                等值连接
                非等值连接
                自链接
            外连接
                左外连接
                右外连接
                全外连接
            交叉连接
    
    
    
## sql92标准

### 一、等值连接
    语法：
        select 查询列表
        from 表1 别名，表2 别名
        where 表1.key=表2.key
        [and 筛选条件]
        [group by 分组字段]
        [having 分组后的筛选]
        [order by 排序字段]
        
    ①多表连接的结果为多表的交集部分
    ②n表连接，至少需要n-1个连接条件
    ③多表的顺序没有要求
    ④一般需要给表取别名
    ⑤可以搭配前面的所有字句：排序，分组，筛选

##### 1.查询女神名和对应的男神名
    select name,boyname 
    from beauty,boys 
    where beauty.boyfriend_id=boys.id;
    
    2.查询员工名和对应的部门名
    select last_name,department_name
    from employees,departments
    where employees.department_id=departments.department_id;
    
##### 2.为表起别名:区分重名字段，简洁
    如果起了别名，则不能用原始表名限定
    
    1.查询员工名，工种号，工种名
    select e.last_name,e.job_id,j.job_title
    from employees e,jobs j
    where e.job_id=j.job_id;
    
##### 3.两个表的顺序可以调换
    select e.last_name,e.job_id,j.job_title
    from jobs j,employees e
    where e.job_id=j.job_id;
    
##### 4.添加筛选
    案例：查询有奖金的员工名和部门名
    select last_name,department_name,commission_pct
    from employees e,departments d
    where e.department_id=d.department_id
    and e.commission_pct is not null;
    
    案例2：查询城市名第二个字符为o的对应的部门名和城市名
    select department_name,city 
    from departments d,locations as l
    where d.location_id=l.location_id
    and city like '_o%';
    
##### 5.添加分组
    案例1：查询每个城市的部门个数
    select count(*),city
    from departments d,locations l
    where d.location_id=l.location_id
    group by city;
    
    案例2：查询有奖金的每个部门名和每个部门领导编号和该部门的最低工资
    select department_name,d.manager_id,min(salary)
    from departments d,employees e
    where d.department_id=e.department_id
    and commission_pct is not null
    group by department_name,manager_id;
    
##### 6.添加排序
    案例：查询每个工种的工种名和员工的个数，按员工个数降序
    select job_title,count(*)
    from employees e,jobs j
    where e.job_id=j.job_id
    group by job_title
    order by count(*) desc;
    
##### 7.可以实现三表连接
    案例：查询员工名，部门名，所在城市
    select last_name,department_name,city
    from employees e,departments d,locations l
    where e.department_id=d.department_id
    and d.location_id=l.location_id and city like 's%'
    order by department_name;
    
### 二、非等值连接
    语法：
        select 查询列表
        from 表1 别名，表2 别名
        where 非等值连接条件
        [and 筛选条件]
        [group by 分组字段]
        [having 分组后的筛选]
        [order by 排序字段]

    案例1：查询员工的工资和工资级别
    select salary,grade_level
    from employees e,job_grades j
    where salary between j.lowest_sal and j.highest_sal
    and grade_level='A';
    
### 三、自连接
    语法：
        select 查询列表
        from 表 别名1，表 别名2
        where 表1.key=表2.key
        [and 筛选条件]
        [group by 分组字段]
        [having 分组后的筛选]
        [order by 排序字段]

    案例1：查询员工名和上级的名称
    select a.employee_id,a.last_name,b.employee_id,b.last_name
    from employees a,employees b
    where a.manager_id=b.employee_id;
    
### 案例查询
    select max(salary),avg(salary) from employees;
    
    select employee_id,job_id,last_name
    from employees 
    order by department_id desc,salary;
    
    select job_id 
    from employees
    where job_id like '%a%e%';
    
    select s.name,g.name,r.score
    from student s,grade g,result r
    where s.id=r.studentNo
    and g.id=s.gradeid;
    
    select now();
    select trim();
    select substr();
    
### 练习
    select last_name,d.department_id,department_name  
    from employees e,departments d 
    where e.department_id=d.department_id;
    
    select job_id,location_id 
    from employees e,departments d 
    where e.department_id=d.department_id and e.department_id=90;

    select last_name,department_name,l.location_id,city  
    from employees e,departments d,locations l 
    where e.department_id=d.department_id 
    and d.location_id=l.location_id 
    and e.commission_pct is not null;
    
    select last_name,job_id,d.department_id,department_name,city 
    from employees e,departments d,locations l 
    where e.department_id=d.department_id 
    and d.location_id=l.location_id 
    and  l.city='Toronto';
    
    select department_name,job_title,min(salary) 
    from departments d,employees e,jobs j 
    where d.department_id=e.department_id 
    and e.job_id=j.job_id group by department_name;
    
    select count(*),country_id 
    from departments d,locations l 
    where d.location_id=l.location_id 
    group by country_id having count(*)>2;
    
    select e.last_name employees,e.employee_id "Emp#",m.last_name manager,m.employee_id 'Mgr#' 
    from employees e, employees m 
    where e.manager_id=m.employee_id 
    and e.last_name='kochhar';
    
## sql99语法
    语法：
        select 查询列表
        from 表1 别名 
        【连接类型】join 表2 别名 on 连接条件
        【where 筛选条件】
        【group by 分组】
        【having 筛选条件】
        【order by 排序列表】
    
    内连接⭐：inner
    外连接：
            左外⭐：left  【outer】
            右外⭐：right 【outer】
            全外：full 【outer】
    交叉连接：cross
    
#### 一、内连接
    语法：
        select 查询列表
        from 表1 别名
        inner join 表2 别名
        on 连接条件;
    
    特点：
        ①添加排序，分组，筛选
        ②inner可以省略
        ③筛选条件放在where后面，连接条件放在on后面
        ④inner join连接和92的等值连接相同
        
##### 1.等值连接
    
    案例1：查询员工名，部门名
    select last_name,department_name 
    from employees e
    inner join departments d
    on e.department_id=d.department_id;
    
    案例2：查询名字中包含e的员工名和工种名（添加筛选）
    select last_name,job_title
    from employees e
    inner join jobs j
    on e.job_id=j.job_id
    where e.last_name like '%e%';
    
    案例3：查询部门个数>3的城市名和部门个数（分组加筛选）
    select count(*),city
    from locations l
    inner join departments d
    on l.location_id=d.location_id
    group by city
    having count(*)>3;
    
    案例4：查询哪个部门的员工个数>3的部门名和员工个数，按个数降序
    select count(*),department_name
    from employees e
    inner join departments d
    on e.department_id=d.department_id
    group by department_name
    having count(*)>3
    order by count(*);
    
    案例5：查询员工名，部门名，工种名，按部门名降序（三表连接）
    select last_name,department_name,job_title
    from employees e
    inner join departments d on e.department_id=d.department_id
    inner join jobs j on j.job_id=e.job_id
    order by department_name desc;
    
### 2.非等值连接
    
    1.查询工资级别
    select salary,grade_level
    from employees e
    inner join job_grades j
    on e.salary between j.lowest_sal and j.highest_sal;
    
    2.查询每个工资级别的个数大于20的个数，按级别排序
    select count(*),grade_level
    from employees e
    inner join job_grades j
    on e.salary between j.lowest_sal and j.highest_sal
    group by grade_level
    having count(*)>20
    order by grade_level;
    
### 3.自连接
    
    1.查询员工的名字和上级的名字
    select e.last_name,m.last_name
    from employees e
    join employees m
    on e.manager_id=m.employee_id;
    
    2.添加筛选
    select e.last_name,m.last_name
    from employees e
    join employees m
    on e.manager_id=m.employee_id
    where e.last_name like '%k%';
    
### 二、外连接
    
    
    
    应用场景：用于查询一个表有，另一个表没有的记录
    
    特点：
        1.外连接的查询结果为主表中所有记录
            如果从表有匹配值即可显示
            如果没有则显示null
            外连接查询结果=内连接结果+主表有而从表没有的记录
        2.左外连接：left join的左边为主表
        右外连接：right join右边为主表
        3.左外和右外交换两个表顺序可以实现同样效果
        4.全外连接=内连接结果+各表单独数据
    
    引入：查询男朋友不在男神表的女神名  
    1.左外
    select b.name,bo.*
    from beauty b
    left join boys bo
    on b.boyfriend_id=bo.id
    where bo.id is null;
    
    2.右外
    select b.name,bo.*
    from boys bo
    right join beauty b
    on b.boyfriend_id=bo.id
    where bo.id is null;
    
    案例1：查询哪个部门没有员工
    左外：
    select d.*,e.employee_id
    from departments d
    left join employees e
    on e.department_id=d.department_id;
    右外：
    select d.*,e.employee_id
    from employees e
    left join departments d
    on e.department_id=d.department_id;
    
    3.全外连接(mysql不支持)：
    select b.*,bo.*
    from beauty b
    full join boys bo
    on b.boyfriend_id=bo.id;
    查询结果合集：交集+各表单独的记录
    
    4.交叉连接:笛卡尔乘积
    select b.*,bo.*
    from beauty b
    cross join boys bo;
    
### 案例练习
    1.查询编号>3的女神的男朋友信息，有则列出，没有输出null
    select b.id,b.name,bo.*
    from beauty b
    left join boys bo
    on b.boyfriend_id=bo.id
    where b.id>3;
    
    2.查询哪个城市没有部门
    select city,d.*
    from departments d
    right join locations l
    on d.location_id=l.location_id
    where d.department_id is null;
    
    3.查询部门名为SAL或IT的员工信息
    select e.*,d.department_name
    from departments d
    left join employees e
    on d.department_id=e.department_id
    where d.department_name in('SAL','IT');
    