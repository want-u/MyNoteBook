# Java-进制和位运算

## 进制介绍

对于整数，有四种表示方式：

1. 二进制：0，1，满2进一，以0b或0B开头
2. 十进制：0-9，满10进一
3. 八进制：0-7，满8进一，以数字0开头
4. 十六进制：0-9及A-F，满16进一，以0x或0X开头，A-F不区分大小写

```
public class BinaryTest {
	public static void main(String[] args) {
		// n1 二进制
		int n1 = 0b1010; // 10
		// n2 10进制
		int n2 = 1010; // 1010
		// n3 8进制
		int n3 = 01010; // 520
		// n4 16进制
		int n4 = 0X1010; // 4112

		System.out.println(n1);
		System.out.println(n2);
		System.out.println(n3);
		System.out.println(n4);
	}
}
```

## 进制转换

### 2进制转换10进制

规则：从最低位（右边）开始，将每个位上的数提取出来，乘以2的（位数-1）次方，然后求和

案例：将 0b1011 转为十进制的数

0b1011 = 1 * 2^(1-1) + 1 * 2^(2-1) + 0 * 2^(3-1) + 1 * 2^(4-1)

​			 = 1 + 2 + 0 + 8 = 11

0b110001100 = 2^2 + 2^3 + 2^7 + 2^8

​					  = 4 + 8 + 128 + 256 = 396

### 8进制转换10进制

规则：从最低位（右边）开始，将每个位上的数提取出来，乘以8的（位数-1）次方，然后求和

案例：将 0234 转为十进制的数

0234 = 4 * 8^0 + 3 * 8^1 + 2 * 8^2 

​		 = 4 + 24 + 128 = 156

02456 = 6 + 5 * 8 + 4 * 8^2 + 2 * 8^3

​			= 6 + 40 + 256 +  1024 = 1326

### 16进制转换10进制

规则：从最低位（右边）开始，将每个位上的数提取出来，乘以16的（位数-1）次方，然后求和

案例：将 0x23A 转为十进制的数

0x23A = 10 * 16^0 + 3 * 16^1 + 2 * 16^2

​			= 10 + 48 + 512 = 570

 0xA45 = 5 + 4 * 16 + 10 * 16^2

​			 = 5 + 64 + 2560 = 2629

### 10进制转换2进制

规则：将该数不断除以2，直到商为0为止，然后将每步得到的余数倒过来，就是对应的 2进制

案例：请将 34 转化为 2进制 = 0B00100010

![image-20210208211105943](https://gitee.com/luoxian1011/pictures/raw/master/image-20210208211105943.png)

```
123 转成 2进制 
2 / 123 1
2 /  61 1
2 /  30 0
2 /  15 1
2 /   7 1
2 /   3 1
2 /   1   => 0B01111011
```

### 10进制转换8进制

规则：将该数不断除以8，直到商为0为止，然后将每步得到的余数倒过来，就是对应的 8进制

案例：请将 131 转化为 2进制 = 0203

![image-20210208211404330](https://gitee.com/luoxian1011/pictures/raw/master/image-20210208211404330.png)

```
678 转成 8进制
8 / 678 6 
8 /  84 4
8 /  10 2
      1  => 01246
```

### 10进制转换16进制

规则：将该数不断除以16，直到商为0为止，然后将每步得到的余数倒过来，就是对应的 16进制

案例：请将 237 转化为 2进制 = 0xED

``` 
8912 转成16进制
16 / 8912 0 
16 /  557 D(13)
16 /   34 2 
        2   => 0x22D0
```

### 2进制转换8进制

规则：从低位开始，将2进制数**每三位一组**，转成对应的8进制数即可

案例：请将 0b11010101 转成 8进制 0325

0b11010101 => 11 010 101

​					 => 3  2  5

```
0b11100101 转 8进制
=> 11 100 101
=> 3 4 5
```



### 2进制转换16进制

规则：从低位开始，将2进制数**每四位一组**，转成对应的16进制数即可

案例：请将 0b11010101 转成 16进制 0xD5

0b11010101 => 1101 0101

​					 => D    5

```
0b1110010110 转成16进制
=> 11 1001 0110
=> 3 9 6
```

### 8进制转换2进制

规则：将8进制数每一位，转成对应的**一个3位二进制数**即可

案例：请将 0237 转成2进制 0b10011111

=> 2      3       7

=> 010  011  111

```
01230 转成2进制 0B 0010 1001 1000
=> 1   2   3   0
=> 001 010 011 000
```



### 16进制转换2进制

规则：将16进制数每一位，转成对应的**一个4位二进制数**即可

案例：请将 0x23B 转成2进制 0b10011111

=> 2      3      B

=> 0010 0011 1011

```
0xAB29 转成 2进制 0B 1010 1011 0010 1001
=> A    B    2    9
=> 1010 1011 0010 1001
```

## 位运算

### 2进制在运算中的说明

1. 2进制是逢2进位的进位制，0、1是基本符
2. 现代的电子计算机技术全部采用的是2进制，因为它只使用0、1两个数字符号，非常简单方便，易于用电子方式实现。计算机内部处理的信息，都是采用2进制数来表示的。2进制数用0和1两个数字及其组合来表示任何数。进位规则是“逢2进1”，数字1在不同的位上代表不同的值，按从右至做的次序，这个值以二倍递增。

### 源码，反码和补码

对于有符号的而言：

1. 2进制的最高位是符号位：0表示正数，1表示负数
2. 正数的源码，反码和补码都一样（三码合一）
3. 负数的反码 = 它的原码符号位不变，其他位取反（0->1 1->0）
4. 负数的补码 = 它的反码 + 1，负数的反码 = 负数的补码 - 1
5. 0 的反码，补码都是0
6. Java没有无符号数，换言之，Java中的数都是有符号的
7. 在计算机运算的时候，都是以补码的方式来运算的
8. 当我们看运算结果的时候，要看它的原码

### 位运算符

Java中有7个位运算（&、|、^、~、>>、<<、>>>）

分别是 按位与&、按位或|、按位异或^，按位取反~，它们的运算规则是：

按位与&：	 两位全为1，结果为1，否则为0

按位或|：		两位有一个为1，结果为1，否则为0

按位异或^：	两位一个为0，一个为1，结果为1，否则为0

按位取反~：	0 -> 1 , 1 -> 0

```
public class BitOperator {
	public static void main(String[] args) {
		/*
		位运算：2&3
		1. 先得到2的补码
		  2的原码 00000000 00000000 00000000 00000010
		  2的补码 00000000 00000000 00000000 00000010
		2. 再得到3的补码
		  3的原码 00000000 00000000 00000000 00000011
		  3的补码 00000000 00000000 00000000 00000011
		3. 2&3
		  00000000 00000000 00000000 00000010
		  00000000 00000000 00000000 00000011
		=>00000000 00000000 00000000 00000010
		=>2
		    
		*/
		System.out.println(2&3); // 2
		/*
		位运算：~-2
		1. 先得到-2的补码
		  -2的原码 10000000 00000000 00000000 00000010
		  -2的反码 11111111 11111111 11111111 11111101
		  -2的补码 11111111 11111111 11111111 11111110
		2. ~-2
		  11111111 11111111 11111111 11111110
		=>00000000 00000000 00000000 00000001
		=>1
		*/
		System.out.println(~-2); // 1

		/*
		位运算：~2
		1. 先得到2的补码
		  -2的原码 00000000 00000000 00000000 00000010
		  -2的补码 00000000 00000000 00000000 00000010
		2. ~2
		  00000000 00000000 00000000 00000010
		=>11111111 11111111 11111111 11111101 [补码]
		=>11111111 11111111 11111111 11111100 [反码]
		=>10000000 00000000 00000000 00000011 [原码]
		=>-3
		*/
		System.out.println(~2); // -3

		/*
		位运算：2|3
		1. 2的补码
		  00000000 00000000 00000000 00000010
		2. 3的补码
		  00000000 00000000 00000000 00000011
		3. 2|3
		  00000000 00000000 00000000 00000010
		  00000000 00000000 00000000 00000011
		=>00000000 00000000 00000000 00000011
		=>3
		*/
		System.out.println(2|3); // 3

		/*
		位运算：2^3
		1. 2的补码
		  00000000 00000000 00000000 00000010
		2. 3的补码
		  00000000 00000000 00000000 00000011
		3. 2^3
		  00000000 00000000 00000000 00000010
		  00000000 00000000 00000000 00000011
		=>00000000 00000000 00000000 00000001
		=>1
		*/
		System.out.println(2^3); // 1
	}
}
```

还有3个位运算符 >>、<<和>>> ，运算规则：

1. 算术右移  >>：低位溢出，符号位不变，并用符号位补溢出的高位
2. 算术左移 <<：符号位不变，低位补0
3. \>>> 逻辑右移也叫无符号右移，运算规则：低位溢出，高位补0
4. 特别说明：没有 <<< 符号

```
public class BitOperator02 {
	public static void main(String[] args) {
		// 1 >> 2
		// 00000001 => 00000000
		// 本质： 1 / 2 / 2 = 0
		System.out.println(1 >> 2);
		// 15 >> 2
		// 本质： 15 / 2 / 2 = 3
		System.out.println(15 >> 2);

		// 1 << 2
		// 00000001 => 00000100
		// 本质： 1 * 2 * 2 = 4
		System.out.println(1 << 2);
		// 3 << 2
		// 本质： 2 * 2 * 2 = 12
		System.out.println(3 << 2);
	}
}
```

